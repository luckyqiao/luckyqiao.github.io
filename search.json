[{"title":"一文搞清楚常见网络代理-代码实战","path":"/2025-05-20-net-proxy-demo.html","content":"在上一篇博客中，我们了解了几种常见的网络代理。本文将通过python代码来实现网络代理。代码仅做学习研究使用，不进行性能考虑。 HTTP代理在上一篇博客中我们了解到，http代理分为普通代理和隧道代理。如果目标服务器是http服务，则使用普通代理；如果目标服务器是https服务，则使用隧道代理。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192import socketimport selectimport threadingimport timeimport loggingimport shutilimport osfrom http.server import HTTPServer, BaseHTTPRequestHandlerfrom urllib.parse import urlparse# 配置日志logging.basicConfig( level=logging.INFO, format=&#x27;%(asctime)s - %(levelname)s - %(message)s&#x27;)logger = logging.getLogger(__name__)class ProxyHandler(BaseHTTPRequestHandler): def do_GET(self): &quot;&quot;&quot;处理 GET 请求&quot;&quot;&quot; self._handle_request(&#x27;GET&#x27;) def do_POST(self): &quot;&quot;&quot;处理 POST 请求&quot;&quot;&quot; self._handle_request(&#x27;POST&#x27;) def do_PUT(self): &quot;&quot;&quot;处理 PUT 请求&quot;&quot;&quot; self._handle_request(&#x27;PUT&#x27;) def do_DELETE(self): &quot;&quot;&quot;处理 DELETE 请求&quot;&quot;&quot; self._handle_request(&#x27;DELETE&#x27;) def do_HEAD(self): &quot;&quot;&quot;处理 HEAD 请求&quot;&quot;&quot; self._handle_request(&#x27;HEAD&#x27;) def do_OPTIONS(self): &quot;&quot;&quot;处理 OPTIONS 请求&quot;&quot;&quot; self._handle_request(&#x27;OPTIONS&#x27;) def do_PATCH(self): &quot;&quot;&quot;处理 PATCH 请求&quot;&quot;&quot; self._handle_request(&#x27;PATCH&#x27;) def _handle_request(self, method): &quot;&quot;&quot;通用请求处理方法&quot;&quot;&quot; try: # 解析目标URL url = urlparse(self.path) if not url.netloc: self.send_error(400, &quot;Bad Request&quot;) return # 创建到目标服务器的连接 target_host = url.netloc target_port = 80 if &#x27;:&#x27; in target_host: target_host, target_port = target_host.split(&#x27;:&#x27;) target_port = int(target_port) # 建立连接 target_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) target_sock.connect((target_host, target_port)) # 读取请求体 content_length = int(self.headers.get(&#x27;Content-Length&#x27;, 0)) body = self.rfile.read(content_length) if content_length &gt; 0 else b&#x27;&#x27; # 构建请求头 request_headers = [] for header, value in self.headers.items(): if header.lower() not in (&#x27;proxy-connection&#x27;, &#x27;connection&#x27;, &#x27;host&#x27;): request_headers.append(f&quot;&#123;header&#125;: &#123;value&#125;&quot;) # 发送请求到目标服务器 request = f&quot;&#123;method&#125; &#123;self.path&#125; HTTP/1.1\\r &quot; request += f&quot;Host: &#123;target_host&#125;\\r &quot; request += &quot;Connection: close\\r &quot; request += &quot;\\r &quot;.join(request_headers) request += &quot;\\r &quot; if body: request += f&quot;Content-Length: &#123;len(body)&#125;\\r &quot; request += &quot;\\r &quot; # 发送请求头和请求体 target_sock.send(request.encode()) if body: target_sock.send(body) # 使用shutil.copyfileobj进行数据传输 target_file = target_sock.makefile(&#x27;rb&#x27;) shutil.copyfileobj(target_file, self.wfile, buffer_size=8192) target_file.close() target_sock.close() except Exception as e: logger.error(f&quot;Error handling &#123;method&#125; request: &#123;e&#125;&quot;) self.send_error(500, f&quot;Internal Server Error: &#123;str(e)&#125;&quot;) def do_CONNECT(self): &quot;&quot;&quot;处理 CONNECT 请求（隧道代理）&quot;&quot;&quot; try: # 解析目标地址 target_host, target_port = self.path.split(&#x27;:&#x27;) target_port = int(target_port) # 创建到目标服务器的连接 target_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) target_sock.connect((target_host, target_port)) # 发送连接成功响应 self.send_response(200, &#x27;Connection Established&#x27;) self.send_header(&#x27;Proxy-Agent&#x27;, &#x27;Python-Proxy&#x27;) self.end_headers() # 获取客户端socket client_sock = self.connection # 设置非阻塞模式 client_sock.setblocking(False) target_sock.setblocking(False) # 使用select进行双向转发 while True: # 使用select监控两个socket readable, _, exceptional = select.select( [client_sock, target_sock], [], [client_sock, target_sock], 1 ) # 检查是否有异常 if exceptional: break # 处理可读的socket for sock in readable: try: # 确定源和目标socket if sock is client_sock: source = client_sock target = target_sock else: source = target_sock target = client_sock # 读取数据 data = source.recv(8192) if not data: return # 发送数据 target.send(data) except Exception as e: logger.error(f&quot;Error in tunnel: &#123;e&#125;&quot;) return except Exception as e: logger.error(f&quot;Error handling CONNECT request: &#123;e&#125;&quot;) self.send_error(500, f&quot;Internal Server Error: &#123;str(e)&#125;&quot;) finally: # 确保连接被关闭 try: client_sock.close() except: pass try: target_sock.close() except: pass def log_message(self, format, *args): &quot;&quot;&quot;自定义日志格式&quot;&quot;&quot; logger.info(f&quot;&#123;self.address_string()&#125; - &#123;format % args&#125;&quot;)def run_proxy(host=&#x27;0.0.0.0&#x27;, port=8080): &quot;&quot;&quot;运行代理服务器&quot;&quot;&quot; server_address = (host, port) httpd = HTTPServer(server_address, ProxyHandler) logger.info(f&quot;Starting proxy server on &#123;host&#125;:&#123;port&#125;&quot;) try: httpd.serve_forever() except KeyboardInterrupt: logger.info(&quot;Shutting down proxy server&quot;) httpd.server_close()if __name__ == &#x27;__main__&#x27;: run_proxy()"},{"title":"一文搞清楚常见网络代理-原理学习","path":"/2022-03-20-net-proxy.html","content":"在日常使用电脑的过程中，我们经常会遇到需要使用代理的情况。但每次在电脑上进行电脑配置时，都会很疑惑。这么多代理方式，我究竟应该选哪一种？ 例如这个是MAC电脑上的代理配置。什么是网页代理，和安全网页代理有什么区别？什么是SOCKS代理？什么又是自动发现代理？ 本文就将以MAC系统的代理配置为基础，同时鉴于我们常常使用的是HTTP&#x2F;HTTPS服务，来谈谈通过代理访问HTTP&#x2F;HTTPS服务的一些实现方式。 HTTP代理HTTP代理即由一台HTTP服务器实现代理功能，包含两种实现方式：普通代理和隧道代理。 普通代理HTTP普通代理在 XXXX 定义。以访问URL http://abc.xyz/index.html 为例 浏览器在识别到需要使用代理进行访问后，会向代理服务器发起请求，请求头为 GET http://abc.xyz/index.html 常规的http请求只会传递host之后的路径，由于代理服务器需要知道目标服务器的信息，所以这里请求路径为完整的目标url。 代理服务器收到请求之后，会向正常的客户端一样，向目标服务器发起请求 GET &#x2F;index.html 代理服务器在获取到目标服务器的响应之后，再将响应返回给客户端。 在这个过程中，对于客户端来说，代理服务器扮演的是客户端的角色；对于目标服务器来说，代理服务器扮演的是客户端的角色。代理服务器在整个过程中，扮演“中间人”的角色。代理服务器需要能够识别HTTP请求的内容，因此这种形式的代理又可以认为是四层代理。 隧道代理上面谈到的普通代理，代理服务器需要识别HTTP请求的内容，才能对报文进行转发。但目前越来越多的网站采用的是HTTPS服务，HTTP报文都进行了端到端的加密，“中间人”方式的普通代理对加密数据就完全无能为力了。因此要对HTTPS服务进行代理，我们需要另外一种代理协议——隧道代理。隧道代理的整个流程如下图： 浏览器先向代理服务器发送一个CONNECT请求, 让代理服务器创建一个到目标服务器的连接。 一旦连接创建好之后，浏览器就可以直接通过这个连接进行数据的发送，代理完全不用关心数据的内容，直接透传即可。理论上，隧道道理可以代理任何一种基于TCP的应用层协议，因此HTTP隧道代理又可称为三层代理。 如果代理的是HTTPS协议，那么连接建立以后，浏览器就可以像直接访问目标服务器一样，通过这个连接与目标服务器进行TLS的握手，以及握手成功之后的数据发送。使用HTTP这种不安全的协议代理HTTPS，能保证通信的安全吗？ 当然是可以的。我们可以看到在整个过程中，除了CONNEECT请求是明文的，其他的数据都要等到TLS握手成功后才会进行，而HTTPS本身就是中间人的天然克星，代理服务器无法获取密钥，也就无法对经过的数据进行解密。而对于CONNECT请求，除了域名和端口之外，不包括url、cookie等其他任何敏感信息。即使是CONNECT请求暴露的域名和端口，在正常不经代理的HTTPS请求中，也可以通过IP信息轻易得到。因此隧道代理并没有影响HTTPS协议的安全性。 正如前面所说，隧道代理可以代理任意一种基于TCP的应用层协议，因此也是可以代理HTTP协议的。然而在各个浏览器的实现都是：如果目标服务器是HTTP服务，那么浏览器会采用普通代理；如果目标服务器是HTTPS服务，则使用隧道代理。 SOCKS代理和HTTP代理协议是基于HTTP协议的一种扩展相比，SOCKS5协议则是一种直接为了代理而设计的一套协议。SOCK5协议和HTTP隧道代理有一些相似，都是先由客户端请求代理服务器创建到目标服务器的连接，连接创建完成之后，直接透传客户端与目标服务器之间的流量。但相比于HTTP的隧道代理，SOCKS5协议除了支持TCP协议之外，还支持UDP协议的透传。 SOCKS协议的详细细节可以参考： https://www.mojidong.com/post/2015-03-07-socket5-1/ MAC中的配置在回到前面说的MAC中的配置，经过验证之后发现： 网页代理(HTTP)只有在访问HTTP服务时才会使用，且使用简单代理协议 安全网页代理(HTTPS)只有在访问HTTPS服务时才会使用，切使用隧道代理协议 如果配置了SOCKS代理，无论是否配置了网页代理和安全网页代理，都会优先采用SOCKS代理","tags":["网络代理"],"categories":["网络代理"]},{"title":"about","path":"/about/index.html","content":"About me"},{"title":"这是分页标题","path":"/wiki/hello/index.html","content":"Hello, this is a wiki"}]