[{"title":"一文搞清楚常见网络代理-代码实战","path":"/2025-05-20-net-proxy-demo.html","content":"在上一篇博客中，我们了解了几种常见的网络代理。本文将通过python代码来实现网络代理。代码仅做学习研究使用，不进行性能考虑。 HTTP代理在上一篇博客中我们了解到，http代理分为普通代理和隧道代理。如果目标服务器是http服务，则使用普通代理；如果目标服务器是https服务，则使用隧道代理。 以下是一个简单的http代理实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193#!/usr/bin/env python3# -*- coding: utf-8 -*-import socketimport selectimport loggingimport shutilfrom http.server import ThreadingHTTPServer, BaseHTTPRequestHandlerfrom urllib.parse import urlparse# 配置日志logging.basicConfig( level=logging.INFO, format=&#x27;%(asctime)s - %(levelname)s - %(message)s&#x27;)logger = logging.getLogger(__name__)class ProxyHandler(BaseHTTPRequestHandler): def do_GET(self): &quot;&quot;&quot;处理 GET 请求&quot;&quot;&quot; self._handle_request(&#x27;GET&#x27;) def do_POST(self): &quot;&quot;&quot;处理 POST 请求&quot;&quot;&quot; self._handle_request(&#x27;POST&#x27;) def do_PUT(self): &quot;&quot;&quot;处理 PUT 请求&quot;&quot;&quot; self._handle_request(&#x27;PUT&#x27;) def do_DELETE(self): &quot;&quot;&quot;处理 DELETE 请求&quot;&quot;&quot; self._handle_request(&#x27;DELETE&#x27;) def do_HEAD(self): &quot;&quot;&quot;处理 HEAD 请求&quot;&quot;&quot; self._handle_request(&#x27;HEAD&#x27;) def do_OPTIONS(self): &quot;&quot;&quot;处理 OPTIONS 请求&quot;&quot;&quot; self._handle_request(&#x27;OPTIONS&#x27;) def do_PATCH(self): &quot;&quot;&quot;处理 PATCH 请求&quot;&quot;&quot; self._handle_request(&#x27;PATCH&#x27;) def _handle_request(self, method): &quot;&quot;&quot;通用请求处理方法&quot;&quot;&quot; try: # 解析目标URL url = urlparse(self.path) if not url.netloc: self.send_error(400, &quot;Bad Request&quot;) return # 创建到目标服务器的连接 target_host = url.netloc target_port = 80 if &#x27;:&#x27; in target_host: target_host, target_port = target_host.split(&#x27;:&#x27;) target_port = int(target_port) # 建立连接 target_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) target_sock.connect((target_host, target_port)) # 读取请求体 content_length = int(self.headers.get(&#x27;Content-Length&#x27;, 0)) body = self.rfile.read(content_length) if content_length &gt; 0 else b&#x27;&#x27; # 构建请求头 request_headers = [] for header, value in self.headers.items(): if header.lower() not in (&#x27;proxy-connection&#x27;, &#x27;connection&#x27;, &#x27;host&#x27;): request_headers.append(f&quot;&#123;header&#125;: &#123;value&#125;&quot;) # 发送请求到目标服务器 request = f&quot;&#123;method&#125; &#123;self.path&#125; HTTP/1.1\\r &quot; request += f&quot;Host: &#123;target_host&#125;\\r &quot; request += &quot;Connection: close\\r &quot; request += &quot;\\r &quot;.join(request_headers) request += &quot;\\r &quot; if body: request += f&quot;Content-Length: &#123;len(body)&#125;\\r &quot; request += &quot;\\r &quot; # 发送请求头和请求体 target_sock.send(request.encode()) if body: target_sock.send(body) # 使用shutil.copyfileobj进行数据传输 target_file = target_sock.makefile(&#x27;rb&#x27;) shutil.copyfileobj(target_file, self.wfile, length=8192) target_file.close() target_sock.close() except Exception as e: logger.error(f&quot;处理 &#123;method&#125; 请求时发生错误: &#123;e&#125;&quot;) self.send_error(500, f&quot;服务器内部错误: &#123;str(e)&#125;&quot;) def do_CONNECT(self): &quot;&quot;&quot;处理 CONNECT 请求（隧道代理）&quot;&quot;&quot; try: # 解析目标地址 target_host, target_port = self.path.split(&#x27;:&#x27;) target_port = int(target_port) # 创建到目标服务器的连接 target_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) target_sock.connect((target_host, target_port)) # 发送连接成功响应 self.send_response(200, &#x27;Connection Established&#x27;) self.send_header(&#x27;Proxy-Agent&#x27;, &#x27;Python-Proxy&#x27;) self.end_headers() # 获取客户端socket client_sock = self.connection # 设置非阻塞模式 client_sock.setblocking(False) target_sock.setblocking(False) # 使用select进行双向转发 while True: # 使用select监控两个socket readable, _, exceptional = select.select( [client_sock, target_sock], [], [client_sock, target_sock], 1 ) # 检查是否有异常 if exceptional: break # 处理可读的socket for sock in readable: try: # 确定源和目标socket if sock is client_sock: source = client_sock target = target_sock else: source = target_sock target = client_sock # 读取数据 data = source.recv(8192) if not data: return # 发送数据 target.send(data) except Exception as e: logger.error(f&quot;隧道连接发生错误: &#123;e&#125;&quot;) return except Exception as e: logger.error(f&quot;处理 CONNECT 请求时发生错误: &#123;e&#125;&quot;) self.send_error(500, f&quot;服务器内部错误: &#123;str(e)&#125;&quot;) finally: # 确保连接被关闭 try: client_sock.close() except: pass try: target_sock.close() except: pass def log_message(self, format, *args): &quot;&quot;&quot;自定义日志格式&quot;&quot;&quot; logger.info(f&quot;&#123;self.address_string()&#125; - &#123;format % args&#125;&quot;)def run_proxy(host=&#x27;0.0.0.0&#x27;, port=9000): &quot;&quot;&quot;运行代理服务器&quot;&quot;&quot; server_address = (host, port) httpd = ThreadingHTTPServer(server_address, ProxyHandler) logger.info(f&quot;代理服务器启动于 &#123;host&#125;:&#123;port&#125;&quot;) try: httpd.serve_forever() except KeyboardInterrupt: logger.info(&quot;正在关闭代理服务器&quot;) httpd.server_close()if __name__ == &#x27;__main__&#x27;: run_proxy() SCOKS代理以下是一个简单的socks代理实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233import socketimport selectimport loggingimport structfrom socketserver import ThreadingTCPServer, StreamRequestHandler# 配置日志logging.basicConfig( level=logging.INFO, format=&#x27;%(asctime)s - %(levelname)s - %(message)s&#x27;)logger = logging.getLogger(__name__)# SOCKS5 协议常量SOCKS_VERSION = 5CONNECT = 1BIND = 2UDP_ASSOCIATE = 3# 地址类型ATYP_IPV4 = 1ATYP_DOMAINNAME = 3ATYP_IPV6 = 4class SocksProxy(StreamRequestHandler): def handle(self): &quot;&quot;&quot;处理SOCKS5连接请求&quot;&quot;&quot; # 处理握手 if not self.handle_handshake(): return # 处理连接请求 if not self.handle_connect(): return def handle_handshake(self): &quot;&quot;&quot;处理SOCKS5握手&quot;&quot;&quot; try: # 读取客户端支持的认证方法 version = self.connection.recv(1) if not version or ord(version) != SOCKS_VERSION: logger.error(f&quot;不支持的SOCKS版本: &#123;version&#125;&quot;) return False # 读取认证方法数量 nmethods = self.connection.recv(1) if not nmethods: return False # 读取所有支持的认证方法 methods = self.connection.recv(ord(nmethods)) if not methods: return False # 目前我们不需要认证，直接返回 NO AUTHENTICATION REQUIRED (0x00) self.connection.sendall(struct.pack(&#x27;!BB&#x27;, SOCKS_VERSION, 0)) return True except Exception as e: logger.error(f&quot;握手阶段错误: &#123;e&#125;&quot;) return False def handle_connect(self): &quot;&quot;&quot;处理SOCKS5连接请求&quot;&quot;&quot; remote = None try: # 读取版本和命令 version, cmd, _, address_type = struct.unpack(&#x27;!BBBB&#x27;, self.connection.recv(4)) if version != SOCKS_VERSION: logger.error(f&quot;不支持的SOCKS版本: &#123;version&#125;&quot;) return False # 目前只支持CONNECT命令 if cmd != CONNECT: logger.error(f&quot;不支持的命令: &#123;cmd&#125;&quot;) self.send_reply(7) # Command not supported return False # 解析目标地址 if address_type == ATYP_IPV4: # IPv4 target_addr = socket.inet_ntoa(self.connection.recv(4)) elif address_type == ATYP_DOMAINNAME: # 域名 domain_length = ord(self.connection.recv(1)) target_addr = self.connection.recv(domain_length).decode() elif address_type == ATYP_IPV6: # IPv6 target_addr = socket.inet_ntop(socket.AF_INET6, self.connection.recv(16)) else: logger.error(f&quot;不支持的地址类型: &#123;address_type&#125;&quot;) self.send_reply(8) # Address type not supported return False # 读取端口号 target_port = struct.unpack(&#x27;!H&#x27;, self.connection.recv(2))[0] # 尝试连接到目标服务器 try: if address_type == ATYP_DOMAINNAME: remote = socket.create_connection((target_addr, target_port), timeout=10) else: remote = socket.socket(socket.AF_INET if address_type == ATYP_IPV4 else socket.AF_INET6) remote.settimeout(10) remote.connect((target_addr, target_port)) bind_address = remote.getsockname() logger.info(f&quot;已连接到 &#123;target_addr&#125;:&#123;target_port&#125;&quot;) # 发送成功响应 self.send_reply(0, bind_address[0], bind_address[1]) except Exception as e: logger.error(f&quot;连接目标服务器失败: &#123;e&#125;&quot;) self.send_reply(4) # Host unreachable return False # 开始转发数据 self.exchange_loop(self.connection, remote) return True except Exception as e: logger.error(f&quot;处理连接请求时发生错误: &#123;e&#125;&quot;) return False finally: if remote: try: remote.close() except: pass def send_reply(self, reply_code, bind_addr=&#x27;0.0.0.0&#x27;, bind_port=0): &quot;&quot;&quot;发送SOCKS5响应&quot;&quot;&quot; try: # 将IP地址转换为网络字节序 if &#x27;:&#x27; in bind_addr: # IPv6 addr_bytes = socket.inet_pton(socket.AF_INET6, bind_addr) addr_type = ATYP_IPV6 else: # IPv4 addr_bytes = socket.inet_aton(bind_addr) addr_type = ATYP_IPV4 reply = struct.pack(&#x27;!BBBB&#x27;, SOCKS_VERSION, reply_code, 0, addr_type) reply += addr_bytes + struct.pack(&#x27;!H&#x27;, bind_port) self.connection.sendall(reply) except Exception as e: logger.error(f&quot;发送响应时发生错误: &#123;e&#125;&quot;) def exchange_loop(self, client, remote): &quot;&quot;&quot;数据交换循环&quot;&quot;&quot; try: client.setblocking(False) remote.setblocking(False) while True: try: r, w, e = select.select([client, remote], [], [], 0.5) except: break if e: break for sock in r: try: data = sock.recv(32768) if not data: return if sock is client: remote.setblocking(True) try: remote.sendall(data) finally: remote.setblocking(False) else: client.setblocking(True) try: client.sendall(data) finally: client.setblocking(False) except: return finally: for sock in [client, remote]: try: sock.close() except: passclass ThreadingSocksServer(ThreadingTCPServer): allow_reuse_address = True daemon_threads = True # 设置为守护线程，这样主线程退出时它们会自动退出 def server_close(self): &quot;&quot;&quot;确保服务器正确关闭&quot;&quot;&quot; try: self.socket.shutdown(socket.SHUT_RDWR) except: pass self.socket.close()def run_proxy(host=&#x27;0.0.0.0&#x27;, port=9001): &quot;&quot;&quot;运行SOCKS5代理服务器&quot;&quot;&quot; server = None def shutdown_server(signum=None, frame=None): nonlocal server if server: logger.info(&quot;正在关闭SOCKS5代理服务器...&quot;) try: server.server_close() # 关闭服务器和所有连接 except: pass logger.info(&quot;服务器已关闭&quot;) import sys sys.exit(0) # 强制退出程序 try: server = ThreadingSocksServer((host, port), SocksProxy) logger.info(f&quot;SOCKS5代理服务器启动在 &#123;host&#125;:&#123;port&#125;&quot;) server.serve_forever() except KeyboardInterrupt: logger.info(&quot;收到KeyboardInterrupt信号&quot;) shutdown_server() except Exception as e: logger.error(f&quot;服务器运行时发生错误: &#123;e&#125;&quot;) shutdown_server()if __name__ == &#x27;__main__&#x27;: run_proxy()"},{"title":"一文搞清楚常见网络代理-原理学习","path":"/2022-03-20-net-proxy.html","content":"在日常使用电脑的过程中，我们经常会遇到需要使用代理的情况。但每次在电脑上进行电脑配置时，都会很疑惑。这么多代理方式，我究竟应该选哪一种？ 例如这个是MAC电脑上的代理配置。什么是网页代理，和安全网页代理有什么区别？什么是SOCKS代理？什么又是自动发现代理？ 本文就将以MAC系统的代理配置为基础，同时鉴于我们常常使用的是HTTP&#x2F;HTTPS服务，来谈谈通过代理访问HTTP&#x2F;HTTPS服务的一些实现方式。 HTTP代理HTTP代理即由一台HTTP服务器实现代理功能，包含两种实现方式：普通代理和隧道代理。 普通代理HTTP普通代理在 XXXX 定义。以访问URL http://abc.xyz/index.html 为例 浏览器在识别到需要使用代理进行访问后，会向代理服务器发起请求，请求头为 GET http://abc.xyz/index.html 常规的http请求只会传递host之后的路径，由于代理服务器需要知道目标服务器的信息，所以这里请求路径为完整的目标url。 代理服务器收到请求之后，会向正常的客户端一样，向目标服务器发起请求 GET &#x2F;index.html 代理服务器在获取到目标服务器的响应之后，再将响应返回给客户端。 在这个过程中，对于客户端来说，代理服务器扮演的是客户端的角色；对于目标服务器来说，代理服务器扮演的是客户端的角色。代理服务器在整个过程中，扮演“中间人”的角色。代理服务器需要能够识别HTTP请求的内容，因此这种形式的代理又可以认为是四层代理。 隧道代理上面谈到的普通代理，代理服务器需要识别HTTP请求的内容，才能对报文进行转发。但目前越来越多的网站采用的是HTTPS服务，HTTP报文都进行了端到端的加密，“中间人”方式的普通代理对加密数据就完全无能为力了。因此要对HTTPS服务进行代理，我们需要另外一种代理协议——隧道代理。隧道代理的整个流程如下图： 浏览器先向代理服务器发送一个CONNECT请求, 让代理服务器创建一个到目标服务器的连接。 一旦连接创建好之后，浏览器就可以直接通过这个连接进行数据的发送，代理完全不用关心数据的内容，直接透传即可。理论上，隧道道理可以代理任何一种基于TCP的应用层协议，因此HTTP隧道代理又可称为三层代理。 如果代理的是HTTPS协议，那么连接建立以后，浏览器就可以像直接访问目标服务器一样，通过这个连接与目标服务器进行TLS的握手，以及握手成功之后的数据发送。使用HTTP这种不安全的协议代理HTTPS，能保证通信的安全吗？ 当然是可以的。我们可以看到在整个过程中，除了CONNEECT请求是明文的，其他的数据都要等到TLS握手成功后才会进行，而HTTPS本身就是中间人的天然克星，代理服务器无法获取密钥，也就无法对经过的数据进行解密。而对于CONNECT请求，除了域名和端口之外，不包括url、cookie等其他任何敏感信息。即使是CONNECT请求暴露的域名和端口，在正常不经代理的HTTPS请求中，也可以通过IP信息轻易得到。因此隧道代理并没有影响HTTPS协议的安全性。 正如前面所说，隧道代理可以代理任意一种基于TCP的应用层协议，因此也是可以代理HTTP协议的。然而在各个浏览器的实现都是：如果目标服务器是HTTP服务，那么浏览器会采用普通代理；如果目标服务器是HTTPS服务，则使用隧道代理。 SOCKS代理和HTTP代理协议是基于HTTP协议的一种扩展相比，SOCKS5协议则是一种直接为了代理而设计的一套协议。SOCK5协议和HTTP隧道代理有一些相似，都是先由客户端请求代理服务器创建到目标服务器的连接，连接创建完成之后，直接透传客户端与目标服务器之间的流量。但相比于HTTP的隧道代理，SOCKS5协议除了支持TCP协议之外，还支持UDP协议的透传。 SOCKS协议的详细细节可以参考： https://www.mojidong.com/post/2015-03-07-socket5-1/ MAC中的配置在回到前面说的MAC中的配置，经过验证之后发现： 网页代理(HTTP)只有在访问HTTP服务时才会使用，且使用简单代理协议 安全网页代理(HTTPS)只有在访问HTTPS服务时才会使用，切使用隧道代理协议 如果配置了SOCKS代理，无论是否配置了网页代理和安全网页代理，都会优先采用SOCKS代理","tags":["网络代理"],"categories":["网络代理"]},{"title":"about","path":"/about/index.html","content":"About me"},{"title":"这是分页标题","path":"/wiki/hello/index.html","content":"Hello, this is a wiki"}]